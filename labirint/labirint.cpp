
#include <iostream> // импортируем библиотеку для ввода-вывода
#include <vector> // импортируем библиотеку для работы с двухмерными массивами
#include <string> // импортируем библиотеку для работы со строками
#include <conio.h> // импортируем библиотеку для работы с функцией _getch(), которая позволяет считывать нажатия клавиш без необходимости нажимать Enter
#include <windows.h> // импортируем библиотеку чтобы установить кодировку UTF-8 в консоли

int main() // начало главной функции программы 
{
	SetConsoleCP(CP_UTF8); // устанавливаем кодировку UTF-8 в консоли
	SetConsoleOutputCP(CP_UTF8); // устанавливаем кодировку UTF-8 в консоли

	int x = 1; // создаем переменную х для хранения координаты игрока по оси Х
	int y = 1; // создаем переменную у для хранения координаты игрока по оси У

// игрок на х=1 у=1

	std::vector<std::string> labirint = { // создаем двухмерный масив который принимает строки
	
		"####################",
		"#@.................#",
		"#####..####..###...#",
		"#..................#",
		"########....########",
		"########..........E#",
		"####################",
	
	
	}; // рисуем наш лабиринт где # - стена, . - пол, @ - игрок, E - финиш

	while (true) { // бесконечный цикл для отрисовки лабиринта и обработки нажатий клавиш
		system("cls"); // очищаем консоль

		for (int i = 0; i < labirint.size(); i++) { // проходимся по каждому елементу масива
			std::cout << labirint[i] << std::endl; // и отрисовываем его в консоль
		}

		char move = _getch(); // создаем переменную move которая будет хранить нажатую клавишу и не ждать нажатия Enter
		if (move == 'w') { // если нажатая клавиша w (вверх), то
			int newY = y - 1; // создаем новую переменную, в которой будет новая координата игрока по оси У, отнимаем потому что в двухмерном массиве движение вверх - это уменьшение индекса строки

			if (labirint[newY][x] == '#') { // если в лабиринте на новой координате стена, то
				continue; // продолжаем не меняю координаты игрока
			}

			if (labirint[newY][x] == 'E') { // если в лабиринте на новой координате финиш, то
				std::cout << "\nПоздравляю, вы прошли лабиринт!" << std::endl; // выводим текст
				break; // выходим из цикла
			}

			else { // в остальном
				labirint[y][x] = '.'; // заменяем текущую позицию игрока на пол (там где игрок был до движения)
				y = newY; // присваиваем новые координаты переменной у
				labirint[y][x] = '@'; // отрисовываем игрока на новой позиции (здесь у нас изменился у, а х остался тем же)
			}
		}

		else if (move == 's') { // если нажатая клавиша s (вниз), то
			int newY = y + 1; // создаем новую переменную, в которой будет новая координата игрока по оси У, прибавляем потому что в двухмерном массиве движение вниз - это увеличение индекса строки
			// аналогично движению вверх
			if (labirint[newY][x] == '#') { // если в лабиринте на новой координате стена, то
				continue; // продолжаем не меняю координаты игрока
			}

			if (labirint[newY][x] == 'E') { // если в лабиринте на новой координате финиш, то
				std::cout << "\nПоздравляю, вы прошли лабиринт!" << std::endl; // выводим текст
				break; // выходим из цикла
			}

			else { // в остальном
				labirint[y][x] = '.'; // заменяем текущую позицию игрока на пол (там где игрок был до движения)
				y = newY; // присваиваем новые координаты переменной у
				labirint[y][x] = '@'; // отрисовываем игрока на новой позиции (здесь у нас изменился у, а х остался тем же)

			}
		}

		else if (move == 'd') { // если нажатая клавиша d (вправо), то
			int newX = x + 1; // создаем новую переменную, в которой будет новая координата игрока по оси Х, прибавляем потому что в двухмерном массиве движение вправо - это увеличение индекса столбца

			if (labirint[y][newX] == '#') { // если в лабиринте на новой координате стена, то
				continue; // продолжаем не меняю координаты игрока
			} 

			if (labirint[y][newX] == 'E') { // если в лабиринте на новой координате финиш, то
				std::cout << "\nПоздравляю, вы прошли лабиринт!" << std::endl; // выводим текст
				break; // выходим из цикла
			}

			else { // в остальном
				labirint[y][x] = '.'; // заменяем текущую позицию игрока на пол (там где игрок был до движения)
				x = newX; // присваиваем новые координаты переменной х
				labirint[y][x] = '@'; // отрисовываем игрока на новой позиции (здесь х изменился, а у остался тем же)
			}
		}

		else if (move == 'a') { // если нажатая клавиша a (влево), то
			int newX = x - 1; // создаем новую переменную, в которой будет новая координата игрока по оси Х, отнимаем потому что в двухмерном массиве движение влево - это уменьшение индекса столбца

			if (labirint[y][newX] == '#') { // если в лабиринте на новой координате стена, то
				continue;// продолжаем не меняю координаты игрока
			}

			if (labirint[y][newX] == 'E') { // если в лабиринте на новой координате финиш, то
				std::cout << "\nПоздравляю, вы прошли лабиринт!" << std::endl; // выводим текст
				break; // выходим из цикла
			}

			else { // в остальном
				labirint[y][x] = '.'; // заменяем текущую позицию игрока на пол (там где игрок был до движения)
				x = newX; // присваиваем новые координаты переменной х
				labirint[y][x] = '@'; // отрисовываем игрока на новой позиции (здесь х изменился, а у остался тем же)
			}

		};
	}
	char endchar = _getch(); // создаем переменную endchar которая ждать нажатую клавишу чтобы программа не закрывалась сразу после окончания, дабы игрок увидел сообщение о победе
	return 0; // конец главной функции программы
}
